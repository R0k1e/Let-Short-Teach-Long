{"id": 11, "generator": "claude-3-sonnet-20240229", "position": "Level 0 Node 0", "flag": "normal", "question": {"question": "How does the excerpt describe the process of managing events within the MySQL database environment, including the key aspects of event creation, modification, execution, and the underlying infrastructure?", "questionCategory": "summary", "comprehension": "semantic"}, "answer": "The provided excerpt describes the process of managing events within the MySQL database environment, covering key aspects such as event creation, modification, execution, and the underlying infrastructure. Here are the detailed points:\n\n1. Event Scheduler State Management:\n- The `switch_event_scheduler_state` function is responsible for enabling or disabling the event scheduler based on the provided state (`EVENTS_ON` or `EVENTS_OFF`).\n- It checks if the event scheduler is disabled via configuration options (`opt_event_scheduler` and `--skip-grant-tables`).\n- If the scheduler is not disabled, it starts or stops the scheduler using the `start` or `stop` methods of the `scheduler` component.\n- It updates the `opt_event_scheduler` option with the new state.\n- The function is synchronized using a mutex lock (`LOCK_event_metadata`).\n\n2. Event Loading from Database:\n- The `load_events_from_db` function loads events from the `mysql.event` table in the database.\n- It opens the `mysql.event` table for reading and iterates over each row to load the event details.\n- For each event, it creates an `Event_queue_element` instance and loads the event data from the row.\n- It checks if the event has the `ON_COMPLETION_DROP` option set and removes the corresponding row from the table if the option is enabled.\n- After loading all events, it reports the number of loaded events.\n- The function is executed within the context of a specific THD (thread), and access control checks are performed to ensure proper privileges.\n\n3. Event Queue and Scheduling:\n- The code references the `Event_queue` and `Event_scheduler` components, which are likely responsible for managing the event execution queue and scheduling events.\n- The `Event_queue_element` class represents an individual event in the queue.\n\n4. Event Storage and Repository:\n- The `db_repository` component is mentioned, which is likely responsible for storing and retrieving event definitions from the database.\n\n5. Error Handling and Access Control:\n- The code includes various error handling mechanisms, such as checking for system table errors and reporting unsupported features.\n- It performs access control checks to ensure proper privileges for event management operations.\n\n6. Locking and Synchronization:\n- The code uses a mutex lock (`LOCK_event_metadata`) to synchronize access to the event metadata and ensure thread-safety during event management operations.\n\n7. Debugging and Monitoring:\n- The code includes references to functions like `dump_internal_status`, which likely provide information about the current state of the event scheduler and event queue for debugging and monitoring purposes.\n\nOverall, the excerpt provides a comprehensive view of the event management infrastructure in MySQL, covering the creation, loading, execution, scheduling, storage, and initialization of events, as well as error handling, access control mechanisms, and synchronization techniques. However, it does not provide detailed information about event modification, deletion, or other aspects like expression reconstruction or schema event listing.", "length": 7673, "text": "// language: C++\n#include \"mysql_priv.h\"\n#include \"events.h\"\n#include \"event_data_objects.h\"\n#include \"event_db_repository.h\"\n#include \"event_queue.h\"\n#include \"event_scheduler.h\"\nstatic const char *opt_event_scheduler_state_names[]=\n    { \"OFF\", \"ON\", \"0\", \"1\", \"DISABLED\", NullS };\n\nconst TYPELIB Events::opt_typelib=\n{\n  array_elements(opt_event_scheduler_state_names)-1,\n  \"\",\n  opt_event_scheduler_state_names,\n  NULL\n};\nstatic const char *var_event_scheduler_state_names[]= { \"OFF\", \"ON\", NullS };\n\nconst TYPELIB Events::var_typelib=\n{\n  array_elements(var_event_scheduler_state_names)-1,\n  \"\",\n  var_event_scheduler_state_names,\n  NULL\n};\n\nEvent_queue *Events::event_queue;\nEvent_scheduler *Events::scheduler;\nEvent_db_repository *Events::db_repository;\nenum Events::enum_opt_event_scheduler\nEvents::opt_event_scheduler= Events::EVENTS_OFF;\npthread_mutex_t Events::LOCK_event_metadata;\nbool Events::check_system_tables_error= FALSE;\nint sortcmp_lex_string(LEX_STRING s, LEX_STRING t, CHARSET_INFO *cs)\n{\n return cs->coll->strnncollsp(cs, (uchar *) s.str,s.length,\n                                  (uchar *) t.str,t.length, 0);\n}\nbool\nEvents::set_opt_event_scheduler(char *argument)\n{\n  if (argument == NULL)\n    opt_event_scheduler= Events::EVENTS_ON;\n  else\n  {\n    int type;\n    /*\n      type=   1   2      3   4      5\n           (OFF | ON) - (0 | 1) (DISABLE )\n    */\n    const static enum enum_opt_event_scheduler type2state[]=\n    { EVENTS_OFF, EVENTS_ON, EVENTS_OFF, EVENTS_ON, EVENTS_DISABLED };\n\n    type= find_type(argument, &opt_typelib, 1);\n\n    DBUG_ASSERT(type >= 0 && type <= 5); /* guaranteed by find_type */\n\n    if (type == 0)\n    {\n      fprintf(stderr, \"Unknown option to event-scheduler: %s\\n\", argument);\n      return TRUE;\n    }\n    opt_event_scheduler= type2state[type-1];\n  }\n  return FALSE;\n}\nconst char *\nEvents::get_opt_event_scheduler_str()\n{\n  const char *str;\n\n  pthread_mutex_lock(&LOCK_event_metadata);\n  str= opt_typelib.type_names[(int) opt_event_scheduler];\n  pthread_mutex_unlock(&LOCK_event_metadata);\n\n  return str;\n}\nbool Events::check_if_system_tables_error()\n{\n  DBUG_ENTER(\"Events::check_if_system_tables_error\");\n\n  if (check_system_tables_error)\n  {\n    my_error(ER_EVENTS_DB_ERROR, MYF(0));\n    DBUG_RETURN(TRUE);\n  }\n\n  DBUG_RETURN(FALSE);\n}\nint\nEvents::reconstruct_interval_expression(String *buf, interval_type interval,\n                                        longlong expression)\n{\n  ulonglong expr= expression;\n  char tmp_buff[128], *end;\n  bool close_quote= TRUE;\n  int multipl= 0;\n  char separator=':';\n\n  switch (interval) {\n  case INTERVAL_YEAR_MONTH:\n    multipl= 12;\n    separator= '-';\n    goto common_1_lev_code;\n  case INTERVAL_DAY_HOUR:\n    multipl= 24;\n    separator='';\n    goto common_1_lev_code;\n  case INTERVAL_HOUR_MINUTE:\n  case INTERVAL_MINUTE_SECOND:\n    multipl= 60;\ncommon_1_lev_code:\n    buf->append('\\'');\n    end= longlong10_to_str(expression/multipl, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));\n    expr= expr - (expr/multipl)*multipl;\n    break;\n  case INTERVAL_DAY_MINUTE:\n  {\n    ulonglong tmp_expr= expr;\n\n    tmp_expr/=(24*60);\n    buf->append('\\'');\n    end= longlong10_to_str(tmp_expr, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// days\n    buf->append(' ');\n\n    tmp_expr= expr - tmp_expr*(24*60);//minutes left\n    end= longlong10_to_str(tmp_expr/60, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// hours\n\n    expr= tmp_expr - (tmp_expr/60)*60;\n}\n    break;\n  case INTERVAL_HOUR_SECOND:\n  {\n    ulonglong tmp_expr= expr;\n\n    buf->append('\\'');\n    end= longlong10_to_str(tmp_expr/3600, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// hours\n    buf->append(':');\n\n    tmp_expr= tmp_expr - (tmp_expr/3600)*3600;\n    end= longlong10_to_str(tmp_expr/60, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// minutes\n\n    expr= tmp_expr - (tmp_expr/60)*60;\n}\n    break;\n  case INTERVAL_DAY_SECOND:\n  {\n    ulonglong tmp_expr= expr;\n\n    tmp_expr/=(24*3600);\n    buf->append('\\'');\n    end= longlong10_to_str(tmp_expr, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// days\n    buf->append(' ');\n\n    end= longlong10_to_str(tmp_expr/3600, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// hours\n    buf->append(':');\n\n    tmp_expr= tmp_expr - (tmp_expr/3600)*3600;\n    end= longlong10_to_str(tmp_expr/60, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// minutes\n\n    expr= tmp_expr - (tmp_expr/60)*60;\n}\n    break;\n  case INTERVAL_DAY_MICROSECOND:\n  case INTERVAL_HOUR_MICROSECOND:\n  case INTERVAL_MINUTE_MICROSECOND:\n  case INTERVAL_SECOND_MICROSECOND:\n  case INTERVAL_MICROSECOND:\n    my_error(ER_NOT_SUPPORTED_YET, MYF(0), \"MICROSECOND\");\n    return 1;\n    break;\n  case INTERVAL_QUARTER:\n    expr/= 3;\n    close_quote= FALSE;\n    break;\n  case INTERVAL_WEEK:\n    expr/= 7;\n  default:\n    close_quote= FALSE;\n    break;\n  }\n  if (close_quote)\n    buf->append(separator);\n  end= longlong10_to_str(expr, tmp_buff, 10);\n  buf->append(tmp_buff, (uint) (end- tmp_buff));\n  if (close_quote)\n    buf->append('\\'');\n\n  return 0;\n}\nstatic int\ncreate_query_string(THD *thd, String *buf)\n{\nif (buf->append(STRING_WITH_LEN(\"CREATE \")))\n    return 1;\n  /* Append definer */\n  append_definer(thd, buf, &(thd->lex->definer->user), &(thd->lex->definer->host));\n  /* Append the left part of thd->query after \"DEFINER\" part */\n  if (buf->append(thd->lex->stmt_definition_begin,\n                  thd->lex->stmt_definition_end -\n                  thd->lex->stmt_definition_begin))\n    return 1;\n \n  return 0;\n}\nbool\nEvents::create_event(THD *thd, Event_parse_data *parse_data,\n                     bool if_not_exists)\n{\n  bool ret;\n  bool save_binlog_row_based, event_already_exists;\n  DBUG_ENTER(\"Events::create_event\");\nif (end_active_trans(thd))\n    DBUG_RETURN(TRUE);\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\nif (parse_data->check_parse_data(thd))\n    DBUG_RETURN(TRUE);\nDBUG_ASSERT(parse_data->expression || parse_data->execute_at);\n\n  if (check_access(thd, EVENT_ACL, parse_data->dbname.str, 0, 0, 0,\n                   is_schema_db(parse_data->dbname.str,\n                                parse_data->dbname.length)))\n    DBUG_RETURN(TRUE);\n\n  if (check_db_dir_existence(parse_data->dbname.str))\n  {\n    my_error(ER_BAD_DB_ERROR, MYF(0), parse_data->dbname.str);\n    DBUG_RETURN(TRUE);\n  }\n\n  if (parse_data->do_not_create)\n    DBUG_RETURN(FALSE);\nsave_binlog_row_based= thd->current_stmt_binlog_row_based;\n  thd->clear_current_stmt_binlog_row_based();\n\n  pthread_mutex_lock(&LOCK_event_metadata);\nif (!(ret= db_repository->create_event(thd, parse_data, if_not_exists,\n                                         &event_already_exists)))\n  {\n    Event_queue_element *new_element;\n    bool dropped= 0;\n\n    if (!event_already_exists)\n    {\n      if (!(new_element= new Event_queue_element()))\n        ret= TRUE;                                // OOM\n      else if ((ret= db_repository->load_named_event(thd, parse_data->dbname,\n                                                     parse_data->name,\n                                                     new_element)))\n      {\n        if (!db_repository->drop_event(thd, parse_data->dbname, parse_data->name,\n                                       TRUE))\n          dropped= 1;\n        delete new_element;\n      }\n      else\n      {\n        /* TODO: do not ignore the out parameter and a possible OOM error! */\n        bool created;\n        if (event_queue)\n          event_queue->create_event(thd, new_element, &created);\n      }\n    }\nif (!dropped)\n    {\nDBUG_ASSERT(thd->query() && thd->query_length());\n      String log_query;\n      if (create_query_string(thd, &log_query))\n      {\n        sql_print_error(\"Event Error: An error occurred while creating query string, \"\n                        \"before writing it into binary log.\");\n        ret= true;\n      }\n      else\nret= write_bin_log(thd, TRUE, log_query.c_ptr(), log_query.length());\n    }\n  }\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  /* Restore the state of binlog format */\n  thd->current_stmt_binlog_row_based= save_binlog_row_based;\n\n  DBUG_RETURN(ret);\n}\nbool\nEvents::update_event(THD *thd, Event_parse_data *parse_data,\n                     LEX_STRING *new_dbname, LEX_STRING *new_name)\n{\n  int ret;\n  bool save_binlog_row_based;\n  Event_queue_element *new_element;\n\n  DBUG_ENTER(\"Events::update_event\");\nif (end_active_trans(thd))\n    DBUG_RETURN(TRUE);\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\n\n  if (parse_data->check_parse_data(thd) || parse_data->do_not_create)\n    DBUG_RETURN(TRUE);\n\n  if (check_access(thd, EVENT_ACL, parse_data->dbname.str, 0, 0, 0,\n                   is_schema_db(parse_data->dbname.str,\n                                parse_data->dbname.length)))\n    DBUG_RETURN(TRUE);\n\n  if (new_dbname)                               /* It's a rename */\n  {\nif (!sortcmp_lex_string(parse_data->dbname, *new_dbname,\n                             system_charset_info) &&\n       !sortcmp_lex_string(parse_data->name, *new_name,\n                             system_charset_info))\n    {\n      my_error(ER_EVENT_SAME_NAME, MYF(0));\n      DBUG_RETURN(TRUE);\n    }\nif (check_access(thd, EVENT_ACL, new_dbname->str, 0, 0, 0,\n                     is_schema_db(new_dbname->str, new_dbname->length)))\n      DBUG_RETURN(TRUE);\nif (check_db_dir_existence(new_dbname->str))\n    {\n      my_error(ER_BAD_DB_ERROR, MYF(0), new_dbname->str);\n      DBUG_RETURN(TRUE);\n    }\n  }\nsave_binlog_row_based= thd->current_stmt_binlog_row_based;\n  thd->clear_current_stmt_binlog_row_based();\n\n  pthread_mutex_lock(&LOCK_event_metadata);\nif (!(ret= db_repository->update_event(thd, parse_data,\n                                         new_dbname, new_name)))\n  {\n    LEX_STRING dbname= new_dbname? *new_dbname : parse_data->dbname;\n    LEX_STRING name= new_name? *new_name : parse_data->name;\n\n    if (!(new_element= new Event_queue_element()))\n      ret= TRUE;                                // OOM\n    else if ((ret= db_repository->load_named_event(thd, dbname, name,\n                                                   new_element)))\n    {\n      DBUG_ASSERT(ret == OP_LOAD_ERROR);\n      delete new_element;\n    }\n    else\n    {\nif (event_queue)\n        event_queue->update_event(thd, parse_data->dbname, parse_data->name,\n                                  new_element);\n      /* Binlog the alter event. */\n      DBUG_ASSERT(thd->query() && thd->query_length());\n      ret= write_bin_log(thd, TRUE, thd->query(), thd->query_length());\n    }\n  }\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  /* Restore the state of binlog format */\n  thd->current_stmt_binlog_row_based= save_binlog_row_based;\n\n  DBUG_RETURN(ret);\n}\nbool\nEvents::drop_event(THD *thd, LEX_STRING dbname, LEX_STRING name, bool if_exists)\n{\n  int ret;\n  bool save_binlog_row_based;\n  DBUG_ENTER(\"Events::drop_event\");\nif (end_active_trans(thd))\n    DBUG_RETURN(TRUE);\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\n\n  if (check_access(thd, EVENT_ACL, dbname.str, 0, 0, 0,\n                   is_schema_db(dbname.str, dbname.length)))\n    DBUG_RETURN(TRUE);\nsave_binlog_row_based= thd->current_stmt_binlog_row_based;\n  thd->clear_current_stmt_binlog_row_based();\n\n  pthread_mutex_lock(&LOCK_event_metadata);\nif (!(ret= db_repository->drop_event(thd, dbname, name, if_exists)))\n  {\n    if (event_queue)\n      event_queue->drop_event(thd, dbname, name);\n    /* Binlog the drop event. */\n    DBUG_ASSERT(thd->query() && thd->query_length());\n    ret= write_bin_log(thd, TRUE, thd->query(), thd->query_length());\n  }\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  /* Restore the state of binlog format */\n  thd->current_stmt_binlog_row_based= save_binlog_row_based;\n  DBUG_RETURN(ret);\n}\nvoid\nEvents::drop_schema_events(THD *thd, char *db)\n{\n  LEX_STRING const db_lex= { db, strlen(db) };\n\n  DBUG_ENTER(\"Events::drop_schema_events\");\n  DBUG_PRINT(\"enter\", (\"dropping events from %s\", db));\npthread_mutex_lock(&LOCK_event_metadata);\n  if (event_queue)\n    event_queue->drop_schema_events(thd, db_lex);\n  db_repository->drop_schema_events(thd, db_lex);\n  pthread_mutex_unlock(&LOCK_event_metadata);\n\n  DBUG_VOID_RETURN;\n}\nstatic bool\nsend_show_create_event(THD *thd, Event_timed *et, Protocol *protocol)\n{\n  char show_str_buf[10 * STRING_BUFFER_USUAL_SIZE];\n  String show_str(show_str_buf, sizeof(show_str_buf), system_charset_info);\n  List<Item> field_list;\n  LEX_STRING sql_mode;\n  const String *tz_name;\n\n  DBUG_ENTER(\"send_show_create_event\");\n\n  show_str.length(0);\n  if (et->get_create_event(thd, &show_str))\n    DBUG_RETURN(TRUE);\n\n  field_list.push_back(new Item_empty_string(\"Event\", NAME_CHAR_LEN));\n\n  if (sys_var_thd_sql_mode::symbolic_mode_representation(thd, et->sql_mode,\n                                                         &sql_mode))\n    DBUG_RETURN(TRUE);\n\n  field_list.push_back(new Item_empty_string(\"sql_mode\", (uint) sql_mode.length));\n\n  tz_name= et->time_zone->get_name();\n\n  field_list.push_back(new Item_empty_string(\"time_zone\",\n                                             tz_name->length()));\n\n  field_list.push_back(new Item_empty_string(\"Create Event\",\n                                             show_str.length()));\n\n  field_list.push_back(\n    new Item_empty_string(\"character_set_client\", MY_CS_NAME_SIZE));\n\n  field_list.push_back(\n    new Item_empty_string(\"collation_connection\", MY_CS_NAME_SIZE));\n\n  field_list.push_back(\n    new Item_empty_string(\"Database Collation\", MY_CS_NAME_SIZE));\n\n  if (protocol->send_fields(&field_list,\n                            Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF))\n    DBUG_RETURN(TRUE);\n\n  protocol->prepare_for_resend();\n\n  protocol->store(et->name.str, et->name.length, system_charset_info);\n  protocol->store(sql_mode.str, sql_mode.length, system_charset_info);\n  protocol->store(tz_name->ptr(), tz_name->length(), system_charset_info);\n  protocol->store(show_str.c_ptr(), show_str.length(),\n                  et->creation_ctx->get_client_cs());\n  protocol->store(et->creation_ctx->get_client_cs()->csname,\n                  strlen(et->creation_ctx->get_client_cs()->csname),\n                  system_charset_info);\n  protocol->store(et->creation_ctx->get_connection_cl()->name,\n                  strlen(et->creation_ctx->get_connection_cl()->name),\n                  system_charset_info);\n  protocol->store(et->creation_ctx->get_db_cl()->name,\n                  strlen(et->creation_ctx->get_db_cl()->name),\n                  system_charset_info);\n\n  if (protocol->write())\n    DBUG_RETURN(TRUE);\n\n  my_eof(thd);\n\n  DBUG_RETURN(FALSE);\n}\nbool\nEvents::show_create_event(THD *thd, LEX_STRING dbname, LEX_STRING name)\n{\n  Open_tables_state open_tables_backup;\n  Event_timed et;\n  bool ret;\n\n  DBUG_ENTER(\"Events::show_create_event\");\n  DBUG_PRINT(\"enter\", (\"name: %s@%s\", dbname.str, name.str));\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\n\n  if (check_access(thd, EVENT_ACL, dbname.str, 0, 0, 0,\n                   is_schema_db(dbname.str, dbname.length)))\n    DBUG_RETURN(TRUE);\nthd->reset_n_backup_open_tables_state(&open_tables_backup);\n  ret= db_repository->load_named_event(thd, dbname, name, &et);\n  thd->restore_backup_open_tables_state(&open_tables_backup);\n\n  if (!ret)\n    ret= send_show_create_event(thd, &et, thd->protocol);\n\n  DBUG_RETURN(ret);\n}\nint\nEvents::fill_schema_events(THD *thd, TABLE_LIST *tables, COND *\n)\n{\n  char *db= NULL;\n  int ret;\n  Open_tables_state open_tables_backup;\n  DBUG_ENTER(\"Events::fill_schema_events\");\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(1);\nif (thd->lex->sql_command == SQLCOM_SHOW_EVENTS)\n  {\n    DBUG_ASSERT(thd->lex->select_lex.db);\n        check_access(thd, EVENT_ACL, thd->lex->select_lex.db, 0, 0, 0, 0))\n      DBUG_RETURN(1);\n    db= thd->lex->select_lex.db;\n  }\nthd->reset_n_backup_open_tables_state(&open_tables_backup);\n  ret= db_repository->fill_schema_events(thd, tables, db);\n  thd->restore_backup_open_tables_state(&open_tables_backup);\n\n  DBUG_RETURN(ret);\n}\nbool\nEvents::init(my_bool opt_noacl_or_bootstrap)\n{\n\n  THD *thd;\n  bool res= FALSE;\n\n  DBUG_ENTER(\"Events::init\");\n\n  /* We need a temporary THD during boot */\n  if (!(thd= new THD()))\n  {\n    res= TRUE;\n    goto end;\n  }\nthd->thread_stack= (char*) &thd;\n  thd->store_globals();\n  lex_start(thd);\nif (!(db_repository= new Event_db_repository))\n  {\n    res= TRUE; /* fatal error: request unireg_abort */\n    goto end;\n  }\nif (opt_noacl_or_bootstrap || Event_db_repository::check_system_tables(thd))\n  {\n    if (! opt_noacl_or_bootstrap)\n    {\n      sql_print_error(\"Event Scheduler: An error occurred when initializing \"\n                      \"system tables. Disabling the Event Scheduler.\");\n      check_system_tables_error= TRUE;\n    }\nopt_event_scheduler= EVENTS_DISABLED;\n    goto end;\n  }\nif (opt_event_scheduler == Events::EVENTS_DISABLED)\n    goto end;\n\n\n  DBUG_ASSERT(opt_event_scheduler == Events::EVENTS_ON ||\n              opt_event_scheduler == Events::EVENTS_OFF);\n\n  if (!(event_queue= new Event_queue) ||\n    !(scheduler= new Event_scheduler(event_queue)))\n  {\n    res= TRUE; /* fatal error: request unireg_abort */\n    goto end;\n  }\n\n  if (event_queue->init_queue(thd) || load_events_from_db(thd) ||\n      (opt_event_scheduler == EVENTS_ON && scheduler->start()))\n  {\n    sql_print_error(\"Event Scheduler: Error while loading from disk.\");\n    res= TRUE; /* fatal error: request unireg_abort */\n    goto end;\n  }\n  Event_worker_thread::init(db_repository);\n\nend:\n  if (res)\n  {\n    delete db_repository;\n    delete event_queue;\n    delete scheduler;\n  }\n  delete thd;\n  /* Remember that we don't have a THD */\n  my_pthread_setspecific_ptr(THR_THD,  NULL);\n\n  DBUG_RETURN(res);\n}\nvoid\nEvents::deinit()\n{\n  DBUG_ENTER(\"Events::deinit\");\n\n  if (opt_event_scheduler!= EVENTS_DISABLED)\n  {\n    delete scheduler;\n    scheduler= NULL;                            /* safety */\n    delete event_queue;\n    event_queue= NULL;                          /* safety */\n  }\n\n  delete db_repository;\n  db_repository= NULL;                          /* safety */\n\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  Inits Events mutexes\n\n  SYNOPSIS\n    Events::init_mutexes()\n      thd  Thread\n*/\n\nvoid\nEvents::init_mutexes()\n{\n  pthread_mutex_init(&LOCK_event_metadata, MY_MUTEX_INIT_FAST);\n}\n\n\n/*\n  Destroys Events mutexes\n\n  SYNOPSIS\n    Events::destroy_mutexes()\n*/\n\nvoid\nEvents::destroy_mutexes()\n{\n  pthread_mutex_destroy(&LOCK_event_metadata);\n}\nvoid\nEvents::dump_internal_status()\n{\n  DBUG_ENTER(\"Events::dump_internal_status\");\n  puts(\"\\n\\n\\nEvents status:\");\n  puts(\"LLA = Last Locked At  LUA = Last Unlocked At\");\n  puts(\"WOC = Waiting On Condition  DL = Data Locked\");\n\n  pthread_mutex_lock(&LOCK_event_metadata);\n  if (opt_event_scheduler == EVENTS_DISABLED)\n    puts(\"The Event Scheduler is disabled\");\n  else\n  {\n    scheduler->dump_internal_status();\n    event_queue->dump_internal_status();\n  }\n\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  DBUG_VOID_RETURN;\n}\nbool\nEvents::switch_event_scheduler_state(enum_opt_event_scheduler new_state)\n{\n  bool ret= FALSE;\n\n  DBUG_ENTER(\"Events::switch_event_scheduler_state\");\n\n  DBUG_ASSERT(new_state == Events::EVENTS_ON ||\n              new_state == Events::EVENTS_OFF);\nif (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\n\n  pthread_mutex_lock(&LOCK_event_metadata);\n\n  if (opt_event_scheduler == EVENTS_DISABLED)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT,\n             MYF(0), \"--event-scheduler=DISABLED or --skip-grant-tables\");\n    ret= TRUE;\n    goto end;\n  }\n\n  if (new_state == EVENTS_ON)\n    ret= scheduler->start();\n  else\n    ret= scheduler->stop();\n\n  if (ret)\n  {\n    my_error(ER_EVENT_SET_VAR_ERROR, MYF(0), 0);\n    goto end;\n  }\n\n  opt_event_scheduler= new_state;\n\nend:\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  DBUG_RETURN(ret);\n}\nbool\nEvents::load_events_from_db(THD *thd)\n{\n  TABLE *table;\n  READ_RECORD read_record_info;\n  bool ret= TRUE;\n  uint count= 0;\n  ulong saved_master_access;\n\n  DBUG_ENTER(\"Events::load_events_from_db\");\n  DBUG_PRINT(\"enter\", (\"thd: 0x%lx\", (long) thd));\nsaved_master_access= thd->security_ctx->master_access;\n  thd->security_ctx->master_access |= SUPER_ACL;\n\n  ret= db_repository->open_event_table(thd, TL_WRITE, &table);\n\n  thd->security_ctx->master_access= saved_master_access;\n\n  if (ret)\n  {\n    sql_print_error(\"Event Scheduler: Failed to open table mysql.event\");\n    DBUG_RETURN(TRUE);\n  }\n\n  init_read_record(&read_record_info, thd, table, NULL, 0, 1, FALSE);\n  while (!(read_record_info.read_record(&read_record_info)))\n  {\n    Event_queue_element *et;\n    bool created;\n    bool drop_on_completion;\n\n    if (!(et= new Event_queue_element))\n      goto end;\n\n    DBUG_PRINT(\"info\", (\"Loading event from row.\"));\n\n    if (et->load_from_row(thd, table))\n    {\n      sql_print_error(\"Event Scheduler: \"\n                      \"Error while loading events from mysql.event. \"\n                      \"The table probably contains bad data or is corrupted\");\n      delete et;\n      goto end;\n    }\n    drop_on_completion= (et->on_completion ==\n                         Event_parse_data::ON_COMPLETION_DROP);\n\n\n    if (event_queue->create_event(thd, et, &created))\n    {\n      /* Out of memory */\n      delete et;\n      goto end;\n    }\n    if (created)\n      count++;\n    else if (drop_on_completion)\n    {\nint rc= table->file->ha_delete_row(table->record[0]);\n      if (rc)\n      {\n        table->file->print_error(rc, MYF(0));\n        goto end;\n      }\n    }\n  }\n  sql_print_information(\"Event Scheduler: Loaded %d event%s\",\n                        count, (count == 1)? \"\" : \"s\");\n  ret= FALSE;\n\nend:\n  end_read_record(&read_record_info);\n\n  close_thread_tables(thd);\n\n  DBUG_RETURN(ret);\n}"}
{"id": 11, "generator": "claude-3-sonnet-20240229", "position": "Level 0 Node 0", "flag": "askWithSourceText", "question": {"question": "Based on the given excerpt, summarize the key steps involved in creating an event and integrating it with the event queue and scheduler in MySQL.", "questionCategory": "summary", "comprehension": "semantic"}, "answer": "Based on the provided code excerpt, the key steps involved in creating an event and integrating it with the event queue and scheduler in MySQL can be summarized as follows:1. Check if the event scheduler is enabled by verifying the value of the `opt_event_scheduler` variable. If it is disabled, an error is raised.2. Open the `mysql.event` table in write mode for storing the event details.3. For each event row in the `mysql.event` table:   a. Create a new `Event_queue_element` object to hold the event data.   b. Load the event data from the row into the `Event_queue_element` object using the `load_from_row` method.   c. Check if the event is set to be dropped on completion based on the `on_completion` flag.   d. Create the event in the event queue by calling `event_queue->create_event`.   e. If the event was successfully created, increment the event count.   f. If the event is set to be dropped on completion, delete the corresponding row from the `mysql.event` table.4. Print a summary message indicating the number of events loaded.5. Close the `mysql.event` table and release any resources used during the loading process.The code excerpt does not provide details on creating a new event or integrating it with the event queue and scheduler. It focuses on loading existing events from the `mysql.event` table into the event queue. However, it can be inferred that creating a new event would involve inserting a new row into the `mysql.event` table, and the event scheduler would automatically pick up the new event during the next load cycle.", "length": 7368, "text": "// language: C++\n#include \"mysql_priv.h\"\n#include \"events.h\"\n#include \"event_data_objects.h\"\n#include \"event_db_repository.h\"\n#include \"event_queue.h\"\n#include \"event_scheduler.h\"\nstatic const char *opt_event_scheduler_state_names[]=\n    { \"OFF\", \"ON\", \"0\", \"1\", \"DISABLED\", NullS };\n\nconst TYPELIB Events::opt_typelib=\n{\n  array_elements(opt_event_scheduler_state_names)-1,\n  \"\",\n  opt_event_scheduler_state_names,\n  NULL\n};\nstatic const char *var_event_scheduler_state_names[]= { \"OFF\", \"ON\", NullS };\n\nconst TYPELIB Events::var_typelib=\n{\n  array_elements(var_event_scheduler_state_names)-1,\n  \"\",\n  var_event_scheduler_state_names,\n  NULL\n};\n\nEvent_queue *Events::event_queue;\nEvent_scheduler *Events::scheduler;\nEvent_db_repository *Events::db_repository;\nenum Events::enum_opt_event_scheduler\nEvents::opt_event_scheduler= Events::EVENTS_OFF;\npthread_mutex_t Events::LOCK_event_metadata;\nbool Events::check_system_tables_error= FALSE;\nint sortcmp_lex_string(LEX_STRING s, LEX_STRING t, CHARSET_INFO *cs)\n{\n return cs->coll->strnncollsp(cs, (uchar *) s.str,s.length,\n                                  (uchar *) t.str,t.length, 0);\n}\nbool\nEvents::set_opt_event_scheduler(char *argument)\n{\n  if (argument == NULL)\n    opt_event_scheduler= Events::EVENTS_ON;\n  else\n  {\n    int type;\n    /*\n      type=   1   2      3   4      5\n           (OFF | ON) - (0 | 1) (DISABLE )\n    */\n    const static enum enum_opt_event_scheduler type2state[]=\n    { EVENTS_OFF, EVENTS_ON, EVENTS_OFF, EVENTS_ON, EVENTS_DISABLED };\n\n    type= find_type(argument, &opt_typelib, 1);\n\n    DBUG_ASSERT(type >= 0 && type <= 5); /* guaranteed by find_type */\n\n    if (type == 0)\n    {\n      fprintf(stderr, \"Unknown option to event-scheduler: %s\\n\", argument);\n      return TRUE;\n    }\n    opt_event_scheduler= type2state[type-1];\n  }\n  return FALSE;\n}\nconst char *\nEvents::get_opt_event_scheduler_str()\n{\n  const char *str;\n\n  pthread_mutex_lock(&LOCK_event_metadata);\n  str= opt_typelib.type_names[(int) opt_event_scheduler];\n  pthread_mutex_unlock(&LOCK_event_metadata);\n\n  return str;\n}\nbool Events::check_if_system_tables_error()\n{\n  DBUG_ENTER(\"Events::check_if_system_tables_error\");\n\n  if (check_system_tables_error)\n  {\n    my_error(ER_EVENTS_DB_ERROR, MYF(0));\n    DBUG_RETURN(TRUE);\n  }\n\n  DBUG_RETURN(FALSE);\n}\nint\nEvents::reconstruct_interval_expression(String *buf, interval_type interval,\n                                        longlong expression)\n{\n  ulonglong expr= expression;\n  char tmp_buff[128], *end;\n  bool close_quote= TRUE;\n  int multipl= 0;\n  char separator=':';\n\n  switch (interval) {\n  case INTERVAL_YEAR_MONTH:\n    multipl= 12;\n    separator= '-';\n    goto common_1_lev_code;\n  case INTERVAL_DAY_HOUR:\n    multipl= 24;\n    separator='';\n    goto common_1_lev_code;\n  case INTERVAL_HOUR_MINUTE:\n  case INTERVAL_MINUTE_SECOND:\n    multipl= 60;\ncommon_1_lev_code:\n    buf->append('\\'');\n    end= longlong10_to_str(expression/multipl, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));\n    expr= expr - (expr/multipl)*multipl;\n    break;\n  case INTERVAL_DAY_MINUTE:\n  {\n    ulonglong tmp_expr= expr;\n\n    tmp_expr/=(24*60);\n    buf->append('\\'');\n    end= longlong10_to_str(tmp_expr, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// days\n    buf->append(' ');\n\n    tmp_expr= expr - tmp_expr*(24*60);//minutes left\n    end= longlong10_to_str(tmp_expr/60, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// hours\n\n    expr= tmp_expr - (tmp_expr/60)*60;\n}\n    break;\n  case INTERVAL_HOUR_SECOND:\n  {\n    ulonglong tmp_expr= expr;\n\n    buf->append('\\'');\n    end= longlong10_to_str(tmp_expr/3600, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// hours\n    buf->append(':');\n\n    tmp_expr= tmp_expr - (tmp_expr/3600)*3600;\n    end= longlong10_to_str(tmp_expr/60, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// minutes\n\n    expr= tmp_expr - (tmp_expr/60)*60;\n}\n    break;\n  case INTERVAL_DAY_SECOND:\n  {\n    ulonglong tmp_expr= expr;\n\n    tmp_expr/=(24*3600);\n    buf->append('\\'');\n    end= longlong10_to_str(tmp_expr, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// days\n    buf->append(' ');\n\n    end= longlong10_to_str(tmp_expr/3600, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// hours\n    buf->append(':');\n\n    tmp_expr= tmp_expr - (tmp_expr/3600)*3600;\n    end= longlong10_to_str(tmp_expr/60, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// minutes\n\n    expr= tmp_expr - (tmp_expr/60)*60;\n}\n    break;\n  case INTERVAL_DAY_MICROSECOND:\n  case INTERVAL_HOUR_MICROSECOND:\n  case INTERVAL_MINUTE_MICROSECOND:\n  case INTERVAL_SECOND_MICROSECOND:\n  case INTERVAL_MICROSECOND:\n    my_error(ER_NOT_SUPPORTED_YET, MYF(0), \"MICROSECOND\");\n    return 1;\n    break;\n  case INTERVAL_QUARTER:\n    expr/= 3;\n    close_quote= FALSE;\n    break;\n  case INTERVAL_WEEK:\n    expr/= 7;\n  default:\n    close_quote= FALSE;\n    break;\n  }\n  if (close_quote)\n    buf->append(separator);\n  end= longlong10_to_str(expr, tmp_buff, 10);\n  buf->append(tmp_buff, (uint) (end- tmp_buff));\n  if (close_quote)\n    buf->append('\\'');\n\n  return 0;\n}\nstatic int\ncreate_query_string(THD *thd, String *buf)\n{\nif (buf->append(STRING_WITH_LEN(\"CREATE \")))\n    return 1;\n  /* Append definer */\n  append_definer(thd, buf, &(thd->lex->definer->user), &(thd->lex->definer->host));\n  /* Append the left part of thd->query after \"DEFINER\" part */\n  if (buf->append(thd->lex->stmt_definition_begin,\n                  thd->lex->stmt_definition_end -\n                  thd->lex->stmt_definition_begin))\n    return 1;\n \n  return 0;\n}\nbool\nEvents::create_event(THD *thd, Event_parse_data *parse_data,\n                     bool if_not_exists)\n{\n  bool ret;\n  bool save_binlog_row_based, event_already_exists;\n  DBUG_ENTER(\"Events::create_event\");\nif (end_active_trans(thd))\n    DBUG_RETURN(TRUE);\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\nif (parse_data->check_parse_data(thd))\n    DBUG_RETURN(TRUE);\nDBUG_ASSERT(parse_data->expression || parse_data->execute_at);\n\n  if (check_access(thd, EVENT_ACL, parse_data->dbname.str, 0, 0, 0,\n                   is_schema_db(parse_data->dbname.str,\n                                parse_data->dbname.length)))\n    DBUG_RETURN(TRUE);\n\n  if (check_db_dir_existence(parse_data->dbname.str))\n  {\n    my_error(ER_BAD_DB_ERROR, MYF(0), parse_data->dbname.str);\n    DBUG_RETURN(TRUE);\n  }\n\n  if (parse_data->do_not_create)\n    DBUG_RETURN(FALSE);\nsave_binlog_row_based= thd->current_stmt_binlog_row_based;\n  thd->clear_current_stmt_binlog_row_based();\n\n  pthread_mutex_lock(&LOCK_event_metadata);\nif (!(ret= db_repository->create_event(thd, parse_data, if_not_exists,\n                                         &event_already_exists)))\n  {\n    Event_queue_element *new_element;\n    bool dropped= 0;\n\n    if (!event_already_exists)\n    {\n      if (!(new_element= new Event_queue_element()))\n        ret= TRUE;                                // OOM\n      else if ((ret= db_repository->load_named_event(thd, parse_data->dbname,\n                                                     parse_data->name,\n                                                     new_element)))\n      {\n        if (!db_repository->drop_event(thd, parse_data->dbname, parse_data->name,\n                                       TRUE))\n          dropped= 1;\n        delete new_element;\n      }\n      else\n      {\n        /* TODO: do not ignore the out parameter and a possible OOM error! */\n        bool created;\n        if (event_queue)\n          event_queue->create_event(thd, new_element, &created);\n      }\n    }\nif (!dropped)\n    {\nDBUG_ASSERT(thd->query() && thd->query_length());\n      String log_query;\n      if (create_query_string(thd, &log_query))\n      {\n        sql_print_error(\"Event Error: An error occurred while creating query string, \"\n                        \"before writing it into binary log.\");\n        ret= true;\n      }\n      else\nret= write_bin_log(thd, TRUE, log_query.c_ptr(), log_query.length());\n    }\n  }\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  /* Restore the state of binlog format */\n  thd->current_stmt_binlog_row_based= save_binlog_row_based;\n\n  DBUG_RETURN(ret);\n}\nbool\nEvents::update_event(THD *thd, Event_parse_data *parse_data,\n                     LEX_STRING *new_dbname, LEX_STRING *new_name)\n{\n  int ret;\n  bool save_binlog_row_based;\n  Event_queue_element *new_element;\n\n  DBUG_ENTER(\"Events::update_event\");\nif (end_active_trans(thd))\n    DBUG_RETURN(TRUE);\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\n\n  if (parse_data->check_parse_data(thd) || parse_data->do_not_create)\n    DBUG_RETURN(TRUE);\n\n  if (check_access(thd, EVENT_ACL, parse_data->dbname.str, 0, 0, 0,\n                   is_schema_db(parse_data->dbname.str,\n                                parse_data->dbname.length)))\n    DBUG_RETURN(TRUE);\n\n  if (new_dbname)                               /* It's a rename */\n  {\nif (!sortcmp_lex_string(parse_data->dbname, *new_dbname,\n                             system_charset_info) &&\n       !sortcmp_lex_string(parse_data->name, *new_name,\n                             system_charset_info))\n    {\n      my_error(ER_EVENT_SAME_NAME, MYF(0));\n      DBUG_RETURN(TRUE);\n    }\nif (check_access(thd, EVENT_ACL, new_dbname->str, 0, 0, 0,\n                     is_schema_db(new_dbname->str, new_dbname->length)))\n      DBUG_RETURN(TRUE);\nif (check_db_dir_existence(new_dbname->str))\n    {\n      my_error(ER_BAD_DB_ERROR, MYF(0), new_dbname->str);\n      DBUG_RETURN(TRUE);\n    }\n  }\nsave_binlog_row_based= thd->current_stmt_binlog_row_based;\n  thd->clear_current_stmt_binlog_row_based();\n\n  pthread_mutex_lock(&LOCK_event_metadata);\nif (!(ret= db_repository->update_event(thd, parse_data,\n                                         new_dbname, new_name)))\n  {\n    LEX_STRING dbname= new_dbname? *new_dbname : parse_data->dbname;\n    LEX_STRING name= new_name? *new_name : parse_data->name;\n\n    if (!(new_element= new Event_queue_element()))\n      ret= TRUE;                                // OOM\n    else if ((ret= db_repository->load_named_event(thd, dbname, name,\n                                                   new_element)))\n    {\n      DBUG_ASSERT(ret == OP_LOAD_ERROR);\n      delete new_element;\n    }\n    else\n    {\nif (event_queue)\n        event_queue->update_event(thd, parse_data->dbname, parse_data->name,\n                                  new_element);\n      /* Binlog the alter event. */\n      DBUG_ASSERT(thd->query() && thd->query_length());\n      ret= write_bin_log(thd, TRUE, thd->query(), thd->query_length());\n    }\n  }\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  /* Restore the state of binlog format */\n  thd->current_stmt_binlog_row_based= save_binlog_row_based;\n\n  DBUG_RETURN(ret);\n}\nbool\nEvents::drop_event(THD *thd, LEX_STRING dbname, LEX_STRING name, bool if_exists)\n{\n  int ret;\n  bool save_binlog_row_based;\n  DBUG_ENTER(\"Events::drop_event\");\nif (end_active_trans(thd))\n    DBUG_RETURN(TRUE);\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\n\n  if (check_access(thd, EVENT_ACL, dbname.str, 0, 0, 0,\n                   is_schema_db(dbname.str, dbname.length)))\n    DBUG_RETURN(TRUE);\nsave_binlog_row_based= thd->current_stmt_binlog_row_based;\n  thd->clear_current_stmt_binlog_row_based();\n\n  pthread_mutex_lock(&LOCK_event_metadata);\nif (!(ret= db_repository->drop_event(thd, dbname, name, if_exists)))\n  {\n    if (event_queue)\n      event_queue->drop_event(thd, dbname, name);\n    /* Binlog the drop event. */\n    DBUG_ASSERT(thd->query() && thd->query_length());\n    ret= write_bin_log(thd, TRUE, thd->query(), thd->query_length());\n  }\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  /* Restore the state of binlog format */\n  thd->current_stmt_binlog_row_based= save_binlog_row_based;\n  DBUG_RETURN(ret);\n}\nvoid\nEvents::drop_schema_events(THD *thd, char *db)\n{\n  LEX_STRING const db_lex= { db, strlen(db) };\n\n  DBUG_ENTER(\"Events::drop_schema_events\");\n  DBUG_PRINT(\"enter\", (\"dropping events from %s\", db));\npthread_mutex_lock(&LOCK_event_metadata);\n  if (event_queue)\n    event_queue->drop_schema_events(thd, db_lex);\n  db_repository->drop_schema_events(thd, db_lex);\n  pthread_mutex_unlock(&LOCK_event_metadata);\n\n  DBUG_VOID_RETURN;\n}\nstatic bool\nsend_show_create_event(THD *thd, Event_timed *et, Protocol *protocol)\n{\n  char show_str_buf[10 * STRING_BUFFER_USUAL_SIZE];\n  String show_str(show_str_buf, sizeof(show_str_buf), system_charset_info);\n  List<Item> field_list;\n  LEX_STRING sql_mode;\n  const String *tz_name;\n\n  DBUG_ENTER(\"send_show_create_event\");\n\n  show_str.length(0);\n  if (et->get_create_event(thd, &show_str))\n    DBUG_RETURN(TRUE);\n\n  field_list.push_back(new Item_empty_string(\"Event\", NAME_CHAR_LEN));\n\n  if (sys_var_thd_sql_mode::symbolic_mode_representation(thd, et->sql_mode,\n                                                         &sql_mode))\n    DBUG_RETURN(TRUE);\n\n  field_list.push_back(new Item_empty_string(\"sql_mode\", (uint) sql_mode.length));\n\n  tz_name= et->time_zone->get_name();\n\n  field_list.push_back(new Item_empty_string(\"time_zone\",\n                                             tz_name->length()));\n\n  field_list.push_back(new Item_empty_string(\"Create Event\",\n                                             show_str.length()));\n\n  field_list.push_back(\n    new Item_empty_string(\"character_set_client\", MY_CS_NAME_SIZE));\n\n  field_list.push_back(\n    new Item_empty_string(\"collation_connection\", MY_CS_NAME_SIZE));\n\n  field_list.push_back(\n    new Item_empty_string(\"Database Collation\", MY_CS_NAME_SIZE));\n\n  if (protocol->send_fields(&field_list,\n                            Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF))\n    DBUG_RETURN(TRUE);\n\n  protocol->prepare_for_resend();\n\n  protocol->store(et->name.str, et->name.length, system_charset_info);\n  protocol->store(sql_mode.str, sql_mode.length, system_charset_info);\n  protocol->store(tz_name->ptr(), tz_name->length(), system_charset_info);\n  protocol->store(show_str.c_ptr(), show_str.length(),\n                  et->creation_ctx->get_client_cs());\n  protocol->store(et->creation_ctx->get_client_cs()->csname,\n                  strlen(et->creation_ctx->get_client_cs()->csname),\n                  system_charset_info);\n  protocol->store(et->creation_ctx->get_connection_cl()->name,\n                  strlen(et->creation_ctx->get_connection_cl()->name),\n                  system_charset_info);\n  protocol->store(et->creation_ctx->get_db_cl()->name,\n                  strlen(et->creation_ctx->get_db_cl()->name),\n                  system_charset_info);\n\n  if (protocol->write())\n    DBUG_RETURN(TRUE);\n\n  my_eof(thd);\n\n  DBUG_RETURN(FALSE);\n}\nbool\nEvents::show_create_event(THD *thd, LEX_STRING dbname, LEX_STRING name)\n{\n  Open_tables_state open_tables_backup;\n  Event_timed et;\n  bool ret;\n\n  DBUG_ENTER(\"Events::show_create_event\");\n  DBUG_PRINT(\"enter\", (\"name: %s@%s\", dbname.str, name.str));\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\n\n  if (check_access(thd, EVENT_ACL, dbname.str, 0, 0, 0,\n                   is_schema_db(dbname.str, dbname.length)))\n    DBUG_RETURN(TRUE);\nthd->reset_n_backup_open_tables_state(&open_tables_backup);\n  ret= db_repository->load_named_event(thd, dbname, name, &et);\n  thd->restore_backup_open_tables_state(&open_tables_backup);\n\n  if (!ret)\n    ret= send_show_create_event(thd, &et, thd->protocol);\n\n  DBUG_RETURN(ret);\n}\nint\nEvents::fill_schema_events(THD *thd, TABLE_LIST *tables, COND *\n)\n{\n  char *db= NULL;\n  int ret;\n  Open_tables_state open_tables_backup;\n  DBUG_ENTER(\"Events::fill_schema_events\");\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(1);\nif (thd->lex->sql_command == SQLCOM_SHOW_EVENTS)\n  {\n    DBUG_ASSERT(thd->lex->select_lex.db);\n        check_access(thd, EVENT_ACL, thd->lex->select_lex.db, 0, 0, 0, 0))\n      DBUG_RETURN(1);\n    db= thd->lex->select_lex.db;\n  }\nthd->reset_n_backup_open_tables_state(&open_tables_backup);\n  ret= db_repository->fill_schema_events(thd, tables, db);\n  thd->restore_backup_open_tables_state(&open_tables_backup);\n\n  DBUG_RETURN(ret);\n}\nbool\nEvents::init(my_bool opt_noacl_or_bootstrap)\n{\n\n  THD *thd;\n  bool res= FALSE;\n\n  DBUG_ENTER(\"Events::init\");\n\n  /* We need a temporary THD during boot */\n  if (!(thd= new THD()))\n  {\n    res= TRUE;\n    goto end;\n  }\nthd->thread_stack= (char*) &thd;\n  thd->store_globals();\n  lex_start(thd);\nif (!(db_repository= new Event_db_repository))\n  {\n    res= TRUE; /* fatal error: request unireg_abort */\n    goto end;\n  }\nif (opt_noacl_or_bootstrap || Event_db_repository::check_system_tables(thd))\n  {\n    if (! opt_noacl_or_bootstrap)\n    {\n      sql_print_error(\"Event Scheduler: An error occurred when initializing \"\n                      \"system tables. Disabling the Event Scheduler.\");\n      check_system_tables_error= TRUE;\n    }\nopt_event_scheduler= EVENTS_DISABLED;\n    goto end;\n  }\nif (opt_event_scheduler == Events::EVENTS_DISABLED)\n    goto end;\n\n\n  DBUG_ASSERT(opt_event_scheduler == Events::EVENTS_ON ||\n              opt_event_scheduler == Events::EVENTS_OFF);\n\n  if (!(event_queue= new Event_queue) ||\n    !(scheduler= new Event_scheduler(event_queue)))\n  {\n    res= TRUE; /* fatal error: request unireg_abort */\n    goto end;\n  }\n\n  if (event_queue->init_queue(thd) || load_events_from_db(thd) ||\n      (opt_event_scheduler == EVENTS_ON && scheduler->start()))\n  {\n    sql_print_error(\"Event Scheduler: Error while loading from disk.\");\n    res= TRUE; /* fatal error: request unireg_abort */\n    goto end;\n  }\n  Event_worker_thread::init(db_repository);\n\nend:\n  if (res)\n  {\n    delete db_repository;\n    delete event_queue;\n    delete scheduler;\n  }\n  delete thd;\n  /* Remember that we don't have a THD */\n  my_pthread_setspecific_ptr(THR_THD,  NULL);\n\n  DBUG_RETURN(res);\n}\nvoid\nEvents::deinit()\n{\n  DBUG_ENTER(\"Events::deinit\");\n\n  if (opt_event_scheduler!= EVENTS_DISABLED)\n  {\n    delete scheduler;\n    scheduler= NULL;                            /* safety */\n    delete event_queue;\n    event_queue= NULL;                          /* safety */\n  }\n\n  delete db_repository;\n  db_repository= NULL;                          /* safety */\n\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  Inits Events mutexes\n\n  SYNOPSIS\n    Events::init_mutexes()\n      thd  Thread\n*/\n\nvoid\nEvents::init_mutexes()\n{\n  pthread_mutex_init(&LOCK_event_metadata, MY_MUTEX_INIT_FAST);\n}\n\n\n/*\n  Destroys Events mutexes\n\n  SYNOPSIS\n    Events::destroy_mutexes()\n*/\n\nvoid\nEvents::destroy_mutexes()\n{\n  pthread_mutex_destroy(&LOCK_event_metadata);\n}\nvoid\nEvents::dump_internal_status()\n{\n  DBUG_ENTER(\"Events::dump_internal_status\");\n  puts(\"\\n\\n\\nEvents status:\");\n  puts(\"LLA = Last Locked At  LUA = Last Unlocked At\");\n  puts(\"WOC = Waiting On Condition  DL = Data Locked\");\n\n  pthread_mutex_lock(&LOCK_event_metadata);\n  if (opt_event_scheduler == EVENTS_DISABLED)\n    puts(\"The Event Scheduler is disabled\");\n  else\n  {\n    scheduler->dump_internal_status();\n    event_queue->dump_internal_status();\n  }\n\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  DBUG_VOID_RETURN;\n}\nbool\nEvents::switch_event_scheduler_state(enum_opt_event_scheduler new_state)\n{\n  bool ret= FALSE;\n\n  DBUG_ENTER(\"Events::switch_event_scheduler_state\");\n\n  DBUG_ASSERT(new_state == Events::EVENTS_ON ||\n              new_state == Events::EVENTS_OFF);\nif (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\n\n  pthread_mutex_lock(&LOCK_event_metadata);\n\n  if (opt_event_scheduler == EVENTS_DISABLED)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT,\n             MYF(0), \"--event-scheduler=DISABLED or --skip-grant-tables\");\n    ret= TRUE;\n    goto end;\n  }\n\n  if (new_state == EVENTS_ON)\n    ret= scheduler->start();\n  else\n    ret= scheduler->stop();\n\n  if (ret)\n  {\n    my_error(ER_EVENT_SET_VAR_ERROR, MYF(0), 0);\n    goto end;\n  }\n\n  opt_event_scheduler= new_state;\n\nend:\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  DBUG_RETURN(ret);\n}\nbool\nEvents::load_events_from_db(THD *thd)\n{\n  TABLE *table;\n  READ_RECORD read_record_info;\n  bool ret= TRUE;\n  uint count= 0;\n  ulong saved_master_access;\n\n  DBUG_ENTER(\"Events::load_events_from_db\");\n  DBUG_PRINT(\"enter\", (\"thd: 0x%lx\", (long) thd));\nsaved_master_access= thd->security_ctx->master_access;\n  thd->security_ctx->master_access |= SUPER_ACL;\n\n  ret= db_repository->open_event_table(thd, TL_WRITE, &table);\n\n  thd->security_ctx->master_access= saved_master_access;\n\n  if (ret)\n  {\n    sql_print_error(\"Event Scheduler: Failed to open table mysql.event\");\n    DBUG_RETURN(TRUE);\n  }\n\n  init_read_record(&read_record_info, thd, table, NULL, 0, 1, FALSE);\n  while (!(read_record_info.read_record(&read_record_info)))\n  {\n    Event_queue_element *et;\n    bool created;\n    bool drop_on_completion;\n\n    if (!(et= new Event_queue_element))\n      goto end;\n\n    DBUG_PRINT(\"info\", (\"Loading event from row.\"));\n\n    if (et->load_from_row(thd, table))\n    {\n      sql_print_error(\"Event Scheduler: \"\n                      \"Error while loading events from mysql.event. \"\n                      \"The table probably contains bad data or is corrupted\");\n      delete et;\n      goto end;\n    }\n    drop_on_completion= (et->on_completion ==\n                         Event_parse_data::ON_COMPLETION_DROP);\n\n\n    if (event_queue->create_event(thd, et, &created))\n    {\n      /* Out of memory */\n      delete et;\n      goto end;\n    }\n    if (created)\n      count++;\n    else if (drop_on_completion)\n    {\nint rc= table->file->ha_delete_row(table->record[0]);\n      if (rc)\n      {\n        table->file->print_error(rc, MYF(0));\n        goto end;\n      }\n    }\n  }\n  sql_print_information(\"Event Scheduler: Loaded %d event%s\",\n                        count, (count == 1)? \"\" : \"s\");\n  ret= FALSE;\n\nend:\n  end_read_record(&read_record_info);\n\n  close_thread_tables(thd);\n\n  DBUG_RETURN(ret);\n}"}
{"id": 11, "question": "What are the available options for the event scheduler state? The opt_event_scheduler variable can be set to EVENTS_OFF, EVENTS_ON, or EVENTS_DISABLED. The var_typelib object defines the possible textual representations.", "text": "// language: C++\n#include \"mysql_priv.h\"\n#include \"events.h\"\n#include \"event_data_objects.h\"\n#include \"event_db_repository.h\"\n#include \"event_queue.h\"\n#include \"event_scheduler.h\"\nstatic const char *opt_event_scheduler_state_names[]=\n    { \"OFF\", \"ON\", \"0\", \"1\", \"DISABLED\", NullS };\n\nconst TYPELIB Events::opt_typelib=\n{\n  array_elements(opt_event_scheduler_state_names)-1,\n  \"\",\n  opt_event_scheduler_state_names,\n  NULL\n};\nstatic const char *var_event_scheduler_state_names[]= { \"OFF\", \"ON\", NullS };\n\nconst TYPELIB Events::var_typelib=\n{\n  array_elements(var_event_scheduler_state_names)-1,\n  \"\",\n  var_event_scheduler_state_names,\n  NULL\n};\n\nEvent_queue *Events::event_queue;\nEvent_scheduler *Events::scheduler;\nEvent_db_repository *Events::db_repository;\nenum Events::enum_opt_event_scheduler\nEvents::opt_event_scheduler= Events::EVENTS_OFF;\npthread_mutex_t Events::LOCK_event_metadata;\nbool Events::check_system_tables_error= FALSE;\nint sortcmp_lex_string(LEX_STRING s, LEX_STRING t, CHARSET_INFO *cs)\n{\n return cs->coll->strnncollsp(cs, (uchar *) s.str,s.length,\n                                  (uchar *) t.str,t.length, 0);\n}\nbool\nEvents::set_opt_event_scheduler(char *argument)\n{\n  if (argument == NULL)\n    opt_event_scheduler= Events::EVENTS_ON;\n  else\n  {\n    int type;\n    /*\n      type=   1   2      3   4      5\n           (OFF | ON) - (0 | 1) (DISABLE )\n    */\n    const static enum enum_opt_event_scheduler type2state[]=\n    { EVENTS_OFF, EVENTS_ON, EVENTS_OFF, EVENTS_ON, EVENTS_DISABLED };\n\n    type= find_type(argument, &opt_typelib, 1);\n\n    DBUG_ASSERT(type >= 0 && type <= 5); /* guaranteed by find_type */\n\n    if (type == 0)\n    {\n      fprintf(stderr, \"Unknown option to event-scheduler: %s\\n\", argument);\n      return TRUE;\n    }\n    opt_event_scheduler= type2state[type-1];\n  }\n  return FALSE;\n}\nconst char *\nEvents::get_opt_event_scheduler_str()\n{\n  const char *str;\n\n  pthread_mutex_lock(&LOCK_event_metadata);\n  str= opt_typelib.type_names[(int) opt_event_scheduler];\n  pthread_mutex_unlock(&LOCK_event_metadata);\n\n  return str;\n}\nbool Events::check_if_system_tables_error()\n{\n  DBUG_ENTER(\"Events::check_if_system_tables_error\");\n\n  if (check_system_tables_error)\n  {\n    my_error(ER_EVENTS_DB_ERROR, MYF(0));\n    DBUG_RETURN(TRUE);\n  }\n\n  DBUG_RETURN(FALSE);\n}\nint\nEvents::reconstruct_interval_expression(String *buf, interval_type interval,\n                                        longlong expression)\n{\n  ulonglong expr= expression;\n  char tmp_buff[128], *end;\n  bool close_quote= TRUE;\n  int multipl= 0;\n  char separator=':';\n\n  switch (interval) {\n  case INTERVAL_YEAR_MONTH:\n    multipl= 12;\n    separator= '-';\n    goto common_1_lev_code;\n  case INTERVAL_DAY_HOUR:\n    multipl= 24;\n    separator='';\n    goto common_1_lev_code;\n  case INTERVAL_HOUR_MINUTE:\n  case INTERVAL_MINUTE_SECOND:\n    multipl= 60;\ncommon_1_lev_code:\n    buf->append('\\'');\n    end= longlong10_to_str(expression/multipl, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));\n    expr= expr - (expr/multipl)*multipl;\n    break;\n  case INTERVAL_DAY_MINUTE:\n  {\n    ulonglong tmp_expr= expr;\n\n    tmp_expr/=(24*60);\n    buf->append('\\'');\n    end= longlong10_to_str(tmp_expr, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// days\n    buf->append(' ');\n\n    tmp_expr= expr - tmp_expr*(24*60);//minutes left\n    end= longlong10_to_str(tmp_expr/60, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// hours\n\n    expr= tmp_expr - (tmp_expr/60)*60;\n}\n    break;\n  case INTERVAL_HOUR_SECOND:\n  {\n    ulonglong tmp_expr= expr;\n\n    buf->append('\\'');\n    end= longlong10_to_str(tmp_expr/3600, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// hours\n    buf->append(':');\n\n    tmp_expr= tmp_expr - (tmp_expr/3600)*3600;\n    end= longlong10_to_str(tmp_expr/60, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// minutes\n\n    expr= tmp_expr - (tmp_expr/60)*60;\n}\n    break;\n  case INTERVAL_DAY_SECOND:\n  {\n    ulonglong tmp_expr= expr;\n\n    tmp_expr/=(24*3600);\n    buf->append('\\'');\n    end= longlong10_to_str(tmp_expr, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// days\n    buf->append(' ');\n\n    end= longlong10_to_str(tmp_expr/3600, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// hours\n    buf->append(':');\n\n    tmp_expr= tmp_expr - (tmp_expr/3600)*3600;\n    end= longlong10_to_str(tmp_expr/60, tmp_buff, 10);\n    buf->append(tmp_buff, (uint) (end- tmp_buff));// minutes\n\n    expr= tmp_expr - (tmp_expr/60)*60;\n}\n    break;\n  case INTERVAL_DAY_MICROSECOND:\n  case INTERVAL_HOUR_MICROSECOND:\n  case INTERVAL_MINUTE_MICROSECOND:\n  case INTERVAL_SECOND_MICROSECOND:\n  case INTERVAL_MICROSECOND:\n    my_error(ER_NOT_SUPPORTED_YET, MYF(0), \"MICROSECOND\");\n    return 1;\n    break;\n  case INTERVAL_QUARTER:\n    expr/= 3;\n    close_quote= FALSE;\n    break;\n  case INTERVAL_WEEK:\n    expr/= 7;\n  default:\n    close_quote= FALSE;\n    break;\n  }\n  if (close_quote)\n    buf->append(separator);\n  end= longlong10_to_str(expr, tmp_buff, 10);\n  buf->append(tmp_buff, (uint) (end- tmp_buff));\n  if (close_quote)\n    buf->append('\\'');\n\n  return 0;\n}\nstatic int\ncreate_query_string(THD *thd, String *buf)\n{\nif (buf->append(STRING_WITH_LEN(\"CREATE \")))\n    return 1;\n  /* Append definer */\n  append_definer(thd, buf, &(thd->lex->definer->user), &(thd->lex->definer->host));\n  /* Append the left part of thd->query after \"DEFINER\" part */\n  if (buf->append(thd->lex->stmt_definition_begin,\n                  thd->lex->stmt_definition_end -\n                  thd->lex->stmt_definition_begin))\n    return 1;\n \n  return 0;\n}\nbool\nEvents::create_event(THD *thd, Event_parse_data *parse_data,\n                     bool if_not_exists)\n{\n  bool ret;\n  bool save_binlog_row_based, event_already_exists;\n  DBUG_ENTER(\"Events::create_event\");\nif (end_active_trans(thd))\n    DBUG_RETURN(TRUE);\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\nif (parse_data->check_parse_data(thd))\n    DBUG_RETURN(TRUE);\nDBUG_ASSERT(parse_data->expression || parse_data->execute_at);\n\n  if (check_access(thd, EVENT_ACL, parse_data->dbname.str, 0, 0, 0,\n                   is_schema_db(parse_data->dbname.str,\n                                parse_data->dbname.length)))\n    DBUG_RETURN(TRUE);\n\n  if (check_db_dir_existence(parse_data->dbname.str))\n  {\n    my_error(ER_BAD_DB_ERROR, MYF(0), parse_data->dbname.str);\n    DBUG_RETURN(TRUE);\n  }\n\n  if (parse_data->do_not_create)\n    DBUG_RETURN(FALSE);\nsave_binlog_row_based= thd->current_stmt_binlog_row_based;\n  thd->clear_current_stmt_binlog_row_based();\n\n  pthread_mutex_lock(&LOCK_event_metadata);\nif (!(ret= db_repository->create_event(thd, parse_data, if_not_exists,\n                                         &event_already_exists)))\n  {\n    Event_queue_element *new_element;\n    bool dropped= 0;\n\n    if (!event_already_exists)\n    {\n      if (!(new_element= new Event_queue_element()))\n        ret= TRUE;                                // OOM\n      else if ((ret= db_repository->load_named_event(thd, parse_data->dbname,\n                                                     parse_data->name,\n                                                     new_element)))\n      {\n        if (!db_repository->drop_event(thd, parse_data->dbname, parse_data->name,\n                                       TRUE))\n          dropped= 1;\n        delete new_element;\n      }\n      else\n      {\n        /* TODO: do not ignore the out parameter and a possible OOM error! */\n        bool created;\n        if (event_queue)\n          event_queue->create_event(thd, new_element, &created);\n      }\n    }\nif (!dropped)\n    {\nDBUG_ASSERT(thd->query() && thd->query_length());\n      String log_query;\n      if (create_query_string(thd, &log_query))\n      {\n        sql_print_error(\"Event Error: An error occurred while creating query string, \"\n                        \"before writing it into binary log.\");\n        ret= true;\n      }\n      else\nret= write_bin_log(thd, TRUE, log_query.c_ptr(), log_query.length());\n    }\n  }\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  /* Restore the state of binlog format */\n  thd->current_stmt_binlog_row_based= save_binlog_row_based;\n\n  DBUG_RETURN(ret);\n}\nbool\nEvents::update_event(THD *thd, Event_parse_data *parse_data,\n                     LEX_STRING *new_dbname, LEX_STRING *new_name)\n{\n  int ret;\n  bool save_binlog_row_based;\n  Event_queue_element *new_element;\n\n  DBUG_ENTER(\"Events::update_event\");\nif (end_active_trans(thd))\n    DBUG_RETURN(TRUE);\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\n\n  if (parse_data->check_parse_data(thd) || parse_data->do_not_create)\n    DBUG_RETURN(TRUE);\n\n  if (check_access(thd, EVENT_ACL, parse_data->dbname.str, 0, 0, 0,\n                   is_schema_db(parse_data->dbname.str,\n                                parse_data->dbname.length)))\n    DBUG_RETURN(TRUE);\n\n  if (new_dbname)                               /* It's a rename */\n  {\nif (!sortcmp_lex_string(parse_data->dbname, *new_dbname,\n                             system_charset_info) &&\n        !sortcmp_lex_string(parse_data->name, *new_name,\n                             system_charset_info))\n    {\n      my_error(ER_EVENT_SAME_NAME, MYF(0));\n      DBUG_RETURN(TRUE);\n    }\nif (check_access(thd, EVENT_ACL, new_dbname->str, 0, 0, 0,\n                     is_schema_db(new_dbname->str, new_dbname->length)))\n      DBUG_RETURN(TRUE);\nif (check_db_dir_existence(new_dbname->str))\n    {\n      my_error(ER_BAD_DB_ERROR, MYF(0), new_dbname->str);\n      DBUG_RETURN(TRUE);\n    }\n  }\nsave_binlog_row_based= thd->current_stmt_binlog_row_based;\n  thd->clear_current_stmt_binlog_row_based();\n\n  pthread_mutex_lock(&LOCK_event_metadata);\nif (!(ret= db_repository->update_event(thd, parse_data,\n                                         new_dbname, new_name)))\n  {\n    LEX_STRING dbname= new_dbname? *new_dbname : parse_data->dbname;\n    LEX_STRING name= new_name? *new_name : parse_data->name;\n\n    if (!(new_element= new Event_queue_element()))\n      ret= TRUE;                                // OOM\n    else if ((ret= db_repository->load_named_event(thd, dbname, name,\n                                                   new_element)))\n    {\n      DBUG_ASSERT(ret == OP_LOAD_ERROR);\n      delete new_element;\n    }\n    else\n    {\nif (event_queue)\n        event_queue->update_event(thd, parse_data->dbname, parse_data->name,\n                                  new_element);\n      /* Binlog the alter event. */\n      DBUG_ASSERT(thd->query() && thd->query_length());\n      ret= write_bin_log(thd, TRUE, thd->query(), thd->query_length());\n    }\n  }\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  /* Restore the state of binlog format */\n  thd->current_stmt_binlog_row_based= save_binlog_row_based;\n\n  DBUG_RETURN(ret);\n}\nbool\nEvents::drop_event(THD *thd, LEX_STRING dbname, LEX_STRING name, bool if_exists)\n{\n  int ret;\n  bool save_binlog_row_based;\n  DBUG_ENTER(\"Events::drop_event\");\nif (end_active_trans(thd))\n    DBUG_RETURN(TRUE);\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\n\n  if (check_access(thd, EVENT_ACL, dbname.str, 0, 0, 0,\n                   is_schema_db(dbname.str, dbname.length)))\n    DBUG_RETURN(TRUE);\nsave_binlog_row_based= thd->current_stmt_binlog_row_based;\n  thd->clear_current_stmt_binlog_row_based();\n\n  pthread_mutex_lock(&LOCK_event_metadata);\nif (!(ret= db_repository->drop_event(thd, dbname, name, if_exists)))\n  {\n    if (event_queue)\n      event_queue->drop_event(thd, dbname, name);\n    /* Binlog the drop event. */\n    DBUG_ASSERT(thd->query() && thd->query_length());\n    ret= write_bin_log(thd, TRUE, thd->query(), thd->query_length());\n  }\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  /* Restore the state of binlog format */\n  thd->current_stmt_binlog_row_based= save_binlog_row_based;\n  DBUG_RETURN(ret);\n}\nvoid\nEvents::drop_schema_events(THD *thd, char *db)\n{\n  LEX_STRING const db_lex= { db, strlen(db) };\n\n  DBUG_ENTER(\"Events::drop_schema_events\");\n  DBUG_PRINT(\"enter\", (\"dropping events from %s\", db));\npthread_mutex_lock(&LOCK_event_metadata);\n  if (event_queue)\n    event_queue->drop_schema_events(thd, db_lex);\n  db_repository->drop_schema_events(thd, db_lex);\n  pthread_mutex_unlock(&LOCK_event_metadata);\n\n  DBUG_VOID_RETURN;\n}\nstatic bool\nsend_show_create_event(THD *thd, Event_timed *et, Protocol *protocol)\n{\n  char show_str_buf[10 * STRING_BUFFER_USUAL_SIZE];\n  String show_str(show_str_buf, sizeof(show_str_buf), system_charset_info);\n  List<Item> field_list;\n  LEX_STRING sql_mode;\n  const String *tz_name;\n\n  DBUG_ENTER(\"send_show_create_event\");\n\n  show_str.length(0);\n  if (et->get_create_event(thd, &show_str))\n    DBUG_RETURN(TRUE);\n\n  field_list.push_back(new Item_empty_string(\"Event\", NAME_CHAR_LEN));\n\n  if (sys_var_thd_sql_mode::symbolic_mode_representation(thd, et->sql_mode,\n                                                         &sql_mode))\n    DBUG_RETURN(TRUE);\n\n  field_list.push_back(new Item_empty_string(\"sql_mode\", (uint) sql_mode.length));\n\n  tz_name= et->time_zone->get_name();\n\n  field_list.push_back(new Item_empty_string(\"time_zone\",\n                                             tz_name->length()));\n\n  field_list.push_back(new Item_empty_string(\"Create Event\",\n                                             show_str.length()));\n\n  field_list.push_back(\n    new Item_empty_string(\"character_set_client\", MY_CS_NAME_SIZE));\n\n  field_list.push_back(\n    new Item_empty_string(\"collation_connection\", MY_CS_NAME_SIZE));\n\n  field_list.push_back(\n    new Item_empty_string(\"Database Collation\", MY_CS_NAME_SIZE));\n\n  if (protocol->send_fields(&field_list,\n                            Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF))\n    DBUG_RETURN(TRUE);\n\n  protocol->prepare_for_resend();\n\n  protocol->store(et->name.str, et->name.length, system_charset_info);\n  protocol->store(sql_mode.str, sql_mode.length, system_charset_info);\n  protocol->store(tz_name->ptr(), tz_name->length(), system_charset_info);\n  protocol->store(show_str.c_ptr(), show_str.length(),\n                  et->creation_ctx->get_client_cs());\n  protocol->store(et->creation_ctx->get_client_cs()->csname,\n                  strlen(et->creation_ctx->get_client_cs()->csname),\n                  system_charset_info);\n  protocol->store(et->creation_ctx->get_connection_cl()->name,\n                  strlen(et->creation_ctx->get_connection_cl()->name),\n                  system_charset_info);\n  protocol->store(et->creation_ctx->get_db_cl()->name,\n                  strlen(et->creation_ctx->get_db_cl()->name),\n                  system_charset_info);\n\n  if (protocol->write())\n    DBUG_RETURN(TRUE);\n\n  my_eof(thd);\n\n  DBUG_RETURN(FALSE);\n}\nbool\nEvents::show_create_event(THD *thd, LEX_STRING dbname, LEX_STRING name)\n{\n  Open_tables_state open_tables_backup;\n  Event_timed et;\n  bool ret;\n\n  DBUG_ENTER(\"Events::show_create_event\");\n  DBUG_PRINT(\"enter\", (\"name: %s@%s\", dbname.str, name.str));\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\n\n  if (check_access(thd, EVENT_ACL, dbname.str, 0, 0, 0,\n                   is_schema_db(dbname.str, dbname.length)))\n    DBUG_RETURN(TRUE);\nthd->reset_n_backup_open_tables_state(&open_tables_backup);\n  ret= db_repository->load_named_event(thd, dbname, name, &et);\n  thd->restore_backup_open_tables_state(&open_tables_backup);\n\n  if (!ret)\n    ret= send_show_create_event(thd, &et, thd->protocol);\n\n  DBUG_RETURN(ret);\n}\nint\nEvents::fill_schema_events(THD *thd, TABLE_LIST *tables, COND *\n)\n{\n  char *db= NULL;\n  int ret;\n  Open_tables_state open_tables_backup;\n  DBUG_ENTER(\"Events::fill_schema_events\");\n\n  if (check_if_system_tables_error())\n    DBUG_RETURN(1);\nif (thd->lex->sql_command == SQLCOM_SHOW_EVENTS)\n  {\n    DBUG_ASSERT(thd->lex->select_lex.db);\n        check_access(thd, EVENT_ACL, thd->lex->select_lex.db, 0, 0, 0, 0))\n      DBUG_RETURN(1);\n    db= thd->lex->select_lex.db;\n  }\nthd->reset_n_backup_open_tables_state(&open_tables_backup);\n  ret= db_repository->fill_schema_events(thd, tables, db);\n  thd->restore_backup_open_tables_state(&open_tables_backup);\n\n  DBUG_RETURN(ret);\n}\nbool\nEvents::init(my_bool opt_noacl_or_bootstrap)\n{\n\n  THD *thd;\n  bool res= FALSE;\n\n  DBUG_ENTER(\"Events::init\");\n\n  /* We need a temporary THD during boot */\n  if (!(thd= new THD()))\n  {\n    res= TRUE;\n    goto end;\n  }\nthd->thread_stack= (char*) &thd;\n  thd->store_globals();\n  lex_start(thd);\nif (!(db_repository= new Event_db_repository))\n  {\n    res= TRUE; /* fatal error: request unireg_abort */\n    goto end;\n  }\nif (opt_noacl_or_bootstrap || Event_db_repository::check_system_tables(thd))\n  {\n    if (! opt_noacl_or_bootstrap)\n    {\n      sql_print_error(\"Event Scheduler: An error occurred when initializing \"\n                      \"system tables. Disabling the Event Scheduler.\");\n      check_system_tables_error= TRUE;\n    }\nopt_event_scheduler= EVENTS_DISABLED;\n    goto end;\n  }\nif (opt_event_scheduler == Events::EVENTS_DISABLED)\n    goto end;\n\n\n  DBUG_ASSERT(opt_event_scheduler == Events::EVENTS_ON ||\n              opt_event_scheduler == Events::EVENTS_OFF);\n\n  if (!(event_queue= new Event_queue) ||\n     !(scheduler= new Event_scheduler(event_queue)))\n  {\n    res= TRUE; /* fatal error: request unireg_abort */\n    goto end;\n  }\n\n  if (event_queue->init_queue(thd) || load_events_from_db(thd) ||\n      (opt_event_scheduler == EVENTS_ON && scheduler->start()))\n  {\n    sql_print_error(\"Event Scheduler: Error while loading from disk.\");\n    res= TRUE; /* fatal error: request unireg_abort */\n    goto end;\n  }\n  Event_worker_thread::init(db_repository);\n\nend:\n  if (res)\n  {\n    delete db_repository;\n    delete event_queue;\n    delete scheduler;\n  }\n  delete thd;\n  /* Remember that we don't have a THD */\n  my_pthread_setspecific_ptr(THR_THD,  NULL);\n\n  DBUG_RETURN(res);\n}\nvoid\nEvents::deinit()\n{\n  DBUG_ENTER(\"Events::deinit\");\n\n  if (opt_event_scheduler!= EVENTS_DISABLED)\n  {\n    delete scheduler;\n    scheduler= NULL;                            /* safety */\n    delete event_queue;\n    event_queue= NULL;                          /* safety */\n  }\n\n  delete db_repository;\n  db_repository= NULL;                          /* safety */\n\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  Inits Events mutexes\n\n  SYNOPSIS\n    Events::init_mutexes()\n      thd  Thread\n*/\n\nvoid\nEvents::init_mutexes()\n{\n  pthread_mutex_init(&LOCK_event_metadata, MY_MUTEX_INIT_FAST);\n}\n\n\n/*\n  Destroys Events mutexes\n\n  SYNOPSIS\n    Events::destroy_mutexes()\n*/\n\nvoid\nEvents::destroy_mutexes()\n{\n  pthread_mutex_destroy(&LOCK_event_metadata);\n}\nvoid\nEvents::dump_internal_status()\n{\n  DBUG_ENTER(\"Events::dump_internal_status\");\n  puts(\"\\n\\n\\nEvents status:\");\n  puts(\"LLA = Last Locked At  LUA = Last Unlocked At\");\n  puts(\"WOC = Waiting On Condition  DL = Data Locked\");\n\n  pthread_mutex_lock(&LOCK_event_metadata);\n  if (opt_event_scheduler == EVENTS_DISABLED)\n    puts(\"The Event Scheduler is disabled\");\n  else\n  {\n    scheduler->dump_internal_status();\n    event_queue->dump_internal_status();\n  }\n\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  DBUG_VOID_RETURN;\n}\nbool\nEvents::switch_event_scheduler_state(enum_opt_event_scheduler new_state)\n{\n  bool ret= FALSE;\n\n  DBUG_ENTER(\"Events::switch_event_scheduler_state\");\n\n  DBUG_ASSERT(new_state == Events::EVENTS_ON ||\n              new_state == Events::EVENTS_OFF);\nif (check_if_system_tables_error())\n    DBUG_RETURN(TRUE);\n\n  pthread_mutex_lock(&LOCK_event_metadata);\n\n  if (opt_event_scheduler == EVENTS_DISABLED)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT,\n             MYF(0), \"--event-scheduler=DISABLED or --skip-grant-tables\");\n    ret= TRUE;\n    goto end;\n  }\n\n  if (new_state == EVENTS_ON)\n    ret= scheduler->start();\n  else\n    ret= scheduler->stop();\n\n  if (ret)\n  {\n    my_error(ER_EVENT_SET_VAR_ERROR, MYF(0), 0);\n    goto end;\n  }\n\n  opt_event_scheduler= new_state;\n\nend:\n  pthread_mutex_unlock(&LOCK_event_metadata);\n  DBUG_RETURN(ret);\n}\nbool\nEvents::load_events_from_db(THD *thd)\n{\n  TABLE *table;\n  READ_RECORD read_record_info;\n  bool ret= TRUE;\n  uint count= 0;\n  ulong saved_master_access;\n\n  DBUG_ENTER(\"Events::load_events_from_db\");\n  DBUG_PRINT(\"enter\", (\"thd: 0x%lx\", (long) thd));\nsaved_master_access= thd->security_ctx->master_access;\n  thd->security_ctx->master_access |= SUPER_ACL;\n\n  ret= db_repository->open_event_table(thd, TL_WRITE, &table);\n\n  thd->security_ctx->master_access= saved_master_access;\n\n  if (ret)\n  {\n    sql_print_error(\"Event Scheduler: Failed to open table mysql.event\");\n    DBUG_RETURN(TRUE);\n  }\n\n  init_read_record(&read_record_info, thd, table, NULL, 0, 1, FALSE);\n  while (!(read_record_info.read_record(&read_record_info)))\n  {\n    Event_queue_element *et;\n    bool created;\n    bool drop_on_completion;\n\n    if (!(et= new Event_queue_element))\n      goto end;\n\n    DBUG_PRINT(\"info\", (\"Loading event from row.\"));\n\n    if (et->load_from_row(thd, table))\n    {\n      sql_print_error(\"Event Scheduler: \"\n                      \"Error while loading events from mysql.event. \"\n                      \"The table probably contains bad data or is corrupted\");\n      delete et;\n      goto end;\n    }\n    drop_on_completion= (et->on_completion ==\n                         Event_parse_data::ON_COMPLETION_DROP);\n\n\n    if (event_queue->create_event(thd, et, &created))\n    {\n      /* Out of memory */\n      delete et;\n      goto end;\n    }\n    if (created)\n      count++;\n    else if (drop_on_completion)\n    {\nint rc= table->file->ha_delete_row(table->record[0]);\n      if (rc)\n      {\n        table->file->print_error(rc, MYF(0));\n        goto end;\n      }\n    }\n  }\n  sql_print_information(\"Event Scheduler: Loaded %d event%s\",\n                        count, (count == 1)? \"\" : \"s\");\n  ret= FALSE;\n\nend:\n  end_read_record(&read_record_info);\n\n  close_thread_tables(thd);\n\n  DBUG_RETURN(ret);\n}"}
{"id": 5, "generator": "claude-3-sonnet-20240229", "position": "Level 1 Node 0", "flag": "normal", "question": {"question": "1200,,?", "questionCategory": "causal reasoning", "comprehension": "semantic"}, "answer": ",,:   -    -         -   -   -   -          ", "length": 15247, "text": "1200\n1200, (),  () 12001200,,,,1200,     1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21? 1?2?3?4?5?6?7?8?9?10?11?12?13? 1?2?3?4?()5?()6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24? 1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22? 1?2?3?4?5?6?7?8?9?10?11? 1?2?3?4?5?6?7?8?9?10?11?12?13?14? 1?2?3?4?5?6?7?8?9?10?11?12? 1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24?25?26?27?28?29?30?31?32?33?34?35? 1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24?25?    1?2?3?4?5?6?7?8?9?10?11?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24?25?26?1?2?3?4? 1?2?3?4?5?6?7?8?1?2?3?4?5?6?7?8?1?2?3?4?1?2?3?4?5?1?2?3?1?2?3?4?5?1?2?3?4?5?6?7?1?2?3?1?2?3?4?5?1?2?3?4?1?2?3? 1?2?3?4?5?6?7?8?9?10?1?2?3?1?2?3?4?5?6?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20? 1?2?3?4? 1?2?3?4?5?6?7?1?2?3?4?1?2?3?4?5?6?7?1?2?3?4?1?2?3?4? 1?2?3?4?5?6?7?8?9?1?2?3?4?5?6?7?8?9?10?11?1?2?3?4?5?6?7?8?9?10?11?1?2?3?4?1?2?3?4?5?6?7?1?2?1?2?1?2?3? 1?2?3?4?5?6?1?2?3?4?5?6?7?I8?II9?10?11?12?13? 1?2?1?2?1?2?3?1?2?3?1?2?3?4?5?6?7?8? 1?2?3?4?5?6?1?2?3?4?5?6?7?8?9?10?11?12?13?1?2?3?4?5?6?7?8?9?1?2?3?4?5?6?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?1?2?1?2?3?4?5?6?7?8?1?2?3?I4?II5?6? 1?2?3?4?5?1?2?3?4?5?6?7?8?1?2?3?4?5?6?7?8?9?10?11?12?13?14?1?2?1?2?3?1?2?3?4?5?6?7?8?9?10?11?12?13?14?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?1?2?1?2?1?2?3?1?2?3?1?2?3?4?5?6?7?8?1?2?3?4?5?1?2?3?4?5?6?1?2?1?2?3?4?5?6?7?8?9?1?2?1?2?3?4?5?6?1?2?3?4?5?6?7?8?9?1?2?3?4?1?2?3?4?5?1?2?1?2?3?4?1?2? 1?2?1?2?3?4?5?1?2?3?4?5?6?1?2?3?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?1?2?3?4?5?6?7?8?9?10?11?12?13?1?2?3?4?1?2?1?2?3?1?2?3?4?5?6? 1?2?3?1?2?3?1?2?1?2?1?2?1?2?3?1?2?1?2?1?2? 1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?1?2?3?4?5?6?7?8?1?2?1?2?3?4?1?2?1?2?1?2?3?1?2?3?4?5?6?7?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24?25?26?27?28?29?30?31?32?33?34?35?36?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24?25?26?27?28?29?30?31?32?33?34?35?36?37?38?39?40?41?42?43?44?45?46?47?48?49?50?1?2?1?2?1?2?3?4?5?1?2?1?2?3?4?5?6?1?2?3?4?5?1?2?3?4?5?6?17?28?1?2?3?4?5? 1?2?3?1?2?3?4?5?6?7?1?2?3?1?2?1?2?I3?4?1?2?3?4?5?6?7?8?1?2?3?4?5?6?1?2?3?4?5?6?7?8?9?10?1?2?1?2?3?4?5?1?2?3?4?5?1?2?3?4?5?6?7?8?9?10?11?12?13?1?2?3?4?1?2?3?4?5?6?7?1?2?3?4?5?6?1?II2?3?4?1?2?3?4?5?6?1?2?1?2?3?1?2?1?2?3?4?1?2?3?4?1?2?1?2?3?4?5?6? 1?2?3?1?2?3?1?2?1?2?3?4?1?2?3?4? 1?2?1?2?3?4?5?1?2?3?4?1?2?1?2?3?1?2?1?2?1?2?1?2?3?4?1?2?1?2?3?4?5?6?7?8?9?10?11?1?2?1?2?3?1?2? 1?2?1?2?3?4?5?6?7?8?9?10?1?2?3?1?2?1?2?3?4?5? 1?2?1?2?3?1?2?3?   1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24?25?26?27?28?29?30?31?32?33?34?35?36?37?38?39?40?41?42?43?44?45?46?47?48?49?50?51?52?53?54?55?56?57?58?59?60?61?62?63?64?65?66?67?68?69?70?71?72?73?74?75?     ()()()()()()()()()()()()()  ()() ()()()()()()()()()() "}
{"id": 5, "generator": "claude-3-sonnet-20240229", "position": "Level 1 Node 0", "flag": "askWithSourceText", "question": {"question": ",,:,?", "questionCategory": "causal reasoning", "comprehension": "semantic"}, "answer": ",,,,,,,,,", "length": 15155, "text": "1200\n1200, (),  () 12001200,,,,1200,     1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21? 1?2?3?4?5?6?7?8?9?10?11?12?13? 1?2?3?4?()5?()6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24? 1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22? 1?2?3?4?5?6?7?8?9?10?11? 1?2?3?4?5?6?7?8?9?10?11?12?13?14? 1?2?3?4?5?6?7?8?9?10?11?12? 1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24?25?26?27?28?29?30?31?32?33?34?35? 1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24?25?    1?2?3?4?5?6?7?8?9?10?11?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24?25?26?1?2?3?4? 1?2?3?4?5?6?7?8?1?2?3?4?5?6?7?8?1?2?3?4?1?2?3?4?5?1?2?3?1?2?3?4?5?1?2?3?4?5?6?7?1?2?3?1?2?3?4?5?1?2?3?4?1?2?3? 1?2?3?4?5?6?7?8?9?10?1?2?3?1?2?3?4?5?6?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20? 1?2?3?4? 1?2?3?4?5?6?7?1?2?3?4?1?2?3?4?5?6?7?1?2?3?4?1?2?3?4? 1?2?3?4?5?6?7?8?9?1?2?3?4?5?6?7?8?9?10?11?1?2?3?4?5?6?7?8?9?10?11?1?2?3?4?1?2?3?4?5?6?7?1?2?1?2?1?2?3? 1?2?3?4?5?6?1?2?3?4?5?6?7?I8?II9?10?11?12?13? 1?2?1?2?1?2?3?1?2?3?1?2?3?4?5?6?7?8? 1?2?3?4?5?6?1?2?3?4?5?6?7?8?9?10?11?12?13?1?2?3?4?5?6?7?8?9?1?2?3?4?5?6?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?1?2?1?2?3?4?5?6?7?8?1?2?3?I4?II5?6? 1?2?3?4?5?1?2?3?4?5?6?7?8?1?2?3?4?5?6?7?8?9?10?11?12?13?14?1?2?1?2?3?1?2?3?4?5?6?7?8?9?10?11?12?13?14?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?1?2?1?2?1?2?3?1?2?3?1?2?3?4?5?6?7?8?1?2?3?4?5?1?2?3?4?5?6?1?2?1?2?3?4?5?6?7?8?9?1?2?1?2?3?4?5?6?1?2?3?4?5?6?7?8?9?1?2?3?4?1?2?3?4?5?1?2?1?2?3?4?1?2? 1?2?1?2?3?4?5?1?2?3?4?5?6?1?2?3?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?1?2?3?4?5?6?7?8?9?10?11?12?13?1?2?3?4?1?2?1?2?3?1?2?3?4?5?6? 1?2?3?1?2?3?1?2?1?2?1?2?1?2?3?1?2?1?2?1?2? 1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?1?2?3?4?5?6?7?8?1?2?1?2?3?4?1?2?1?2?1?2?3?1?2?3?4?5?6?7?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24?25?26?27?28?29?30?31?32?33?34?35?36?1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24?25?26?27?28?29?30?31?32?33?34?35?36?37?38?39?40?41?42?43?44?45?46?47?48?49?50?1?2?1?2?1?2?3?4?5?1?2?1?2?3?4?5?6?1?2?3?4?5?1?2?3?4?5?6?17?28?1?2?3?4?5? 1?2?3?1?2?3?4?5?6?7?1?2?3?1?2?1?2?I3?4?1?2?3?4?5?6?7?8?1?2?3?4?5?6?1?2?3?4?5?6?7?8?9?10?1?2?1?2?3?4?5?1?2?3?4?5?1?2?3?4?5?6?7?8?9?10?11?12?13?1?2?3?4?1?2?3?4?5?6?7?1?2?3?4?5?6?1?II2?3?4?1?2?3?4?5?6?1?2?1?2?3?1?2?1?2?3?4?1?2?3?4?1?2?1?2?3?4?5?6? 1?2?3?1?2?3?1?2?1?2?3?4?1?2?3?4? 1?2?1?2?3?4?5?1?2?3?4?1?2?1?2?3?1?2?1?2?1?2?1?2?3?4?1?2?1?2?3?4?5?6?7?8?9?10?11?1?2?1?2?3?1?2? 1?2?1?2?3?4?5?6?7?8?9?10?1?2?3?1?2?1?2?3?4?5? 1?2?1?2?3?1?2?3?   1?2?3?4?5?6?7?8?9?10?11?12?13?14?15?16?17?18?19?20?21?22?23?24?25?26?27?28?29?30?31?32?33?34?35?36?37?38?39?40?41?42?43?44?45?46?47?48?49?50?51?52?53?54?55?56?57?58?59?60?61?62?63?64?65?66?67?68?69?70?71?72?73?74?75?     ()()()()()()()()()()()()()  ()() ()()()()()()()()()() "}
{"id": 5, "question": "?", "text": "1200\n1200 (),  () 120012001200     123456789101112131415161718192021 12345678910111213 123456789101112131415161718192021222324 12345678910111213141516171819202122 1234567891011 1234567891011121314 123456789101112 1234567891011121314151617181920212223242526272829303132333435 12345678910111213141516171819202122232425    123456789101112345678910111213141512345678910111213141516171819202122232425261234 1234567812345678123412345123123451234567123123451234123 123456789101231234561234567891011121314151617181920 1234 12345671234123456712341234 12345678912345678910111234567891011123412345671212123 12345612345678910111213 121212312312345678 123456123456789101112131234567891234561234567891011121314151212345678123456 12345123456781234567891011121314121231234567891011121314123456789101112131415161718192012121231231234567812345123456121234567891212345612345678912341234512123412 121234512345612312345678910111213141516171819202112345678910111213123412123123456 123123121212123121212 12345678910111213141516171819202122123456781212341212123123456712345678910111213141516171819202122232425262728293031323334353612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501212123451212345612345123456172812345 123123456712312123412345678123456123456789101212345123451234567891011121312341234567123456123412345612123121234123412123456 1231231212341234 121234512341212312121212341212345678910111212312 12123456789101231212345 12123123   123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475         "}
